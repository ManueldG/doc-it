<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 7204e2dbb9b484c8b67bb5ad4a93fa1369c5b317 Maintainer: ManueldG Status: ready -->
  <chapter xml:id="security.database" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <title>Sicurezza del Database</title>

   <simpara>
    Al giorno d'oggi, i database sono componenti essenziali di qualsiasi
    applicazione basata sul Web, consentendo ai siti Web di fornire vari contenuti
    dinamici. Poiché anche le informazioni molto sensibili o segrete possono
    essere archiviate in un database, dovresti prendere seriamente in considerazione di 
    protegere i tuoi database.
   </simpara>
   <simpara>
    Per recuperare o archiviare qualsiasi informazione di cui hai bisogno per connetterti al database,
    eseguire una query, recuperare il risultato e quindi chiudere la connessione.
    Oggigiorno, il linguaggio più utilizzato per questo tipo di interazione è 
    l'SQL (Structured Query Language). Di seguito viene mostrato come un'aggressore può <link
    linkend="security.database.sql-injection">manomettere una query SQL</link>.
   </simpara>
   <simpara>
    Come si può immaginare, <acronym>PHP</acronym> non può proteggere il database da solo. 
    Le prossime sezioni puntano a introdurre le modalità di come
    accedere e manipolare ai database all'interno di uno script <acronym>PHP</acronym>.
   </simpara>
   <simpara>
    Bisogna tener presente questa semplice regola: (Defense in Depth) difesa in profondità. Più prendi provvedimenti
    per aumentare la protezione del database, minore è probabilità che un utente malintenzionato
    riesca ad accedere o abusare di eventuali dati archiviati. Una buona progettazione
    dello schema del database e dell'applicazione previene le tue più grandi paure.
   </simpara>

   <sect1 xml:id="security.database.design"> 
    <title>Progetazione del database</title>
     <simpara>
      Il primo passo è quello di creare il database, a meno che non si voglia utilizzarne uno
      di terze parti. Una volta creato il database, gli viene assegnato a un proprietario, 
      che ha eseguito l'istruzione di creazione. Di solito, solo il proprietario 
      (o un superuser) può fare qualsiasi cosa con gli oggetti in quel database e, 
      per consentire ad altri utenti di utilizzarlo, gli devono essere concessi dei privilegi.
     </simpara>
     <simpara>
      Le applicazioni non dovrebbero mai connettersi al database come proprietario o 
      superutente, perché questi utenti possono eseguire qualsiasi query a piacimento, 
      ad esempio, potrebbero modificare lo schema (ad esempio eliminando tabelle) o potrebbero 
      eliminare l'intero contenuto.
     </simpara>
     <simpara>
      E' possibile creare vari utenti del database uno per ogni ruolo della tua applicazione
      con diritti molto limitati sugli elementi del database. Dovrebbero essere concessi
      solo i privilegi necessari per evitare che lo stesso utente possa modificare
      il database tramite le diverse funzionalità. Ciò significa che se gli intrusi ottengono 
      l'accesso al tuo database utilizzando le credenziali delle tue applicazioni, 
      potrebbero apportare tutte le modifiche quante ne sono previsti dai privilegi.
     </simpara> 
   </sect1>

   <sect1 xml:id="security.database.connection">
    <title>Connessione al database</title>
    <simpara>
     E' possibile stabilire connessioni SSL per crittografare le
     comunicazioni client/server per una maggiore sicurezza oppure è possibile utilizzare SSH
     per criptare la connessione di rete tra i client e il server del database.
     Se viene utilizzato uno di questi sistemi, monitorare il traffico e ottenere
     le informazioni sul tuo database saranno difficili da parte di un potenziale malintenzionato.
    </simpara>
    <simpara>
     Se il tuo server database ha il supporto SSL nativo, considera l'utilizzo delle <link
     linkend="ref.openssl">Funzioni OpenSSL</link> nelle comunicazioni tra
     <acronym>PHP</acronym> e database tramite SSL.
    </simpara><!-- XXX 1 controllo (livelli ruoli)-->
   </sect1>

   <sect1 xml:id="security.database.storage"> <!-- tradurlo o lasciarlo in Inglese? -->
    <title>Modello d'archiviazione crittografato - Encrypted Storage Model</title>
    <simpara>
     SSL/SSH protegge i dati che viaggiano dal client al server: SSL/SSH
     non protegge i dati persistenti archiviati in un database. SSL è un
     protocollo on-the-wire.
    </simpara>
    <simpara>
     Una volta che un utente malintenzionato ottiene l'accesso diretto al tuo database (aggirando il server web), 
     i dati sensibili memorizzati potrebbero essere esposti o utilizzati in modo improprio, a meno che
     le informazioni siano protette dal database stesso. La crittografia dei dati
     è un buon modo per limitare questa minaccia, ma pochissimi database offrono
     questo tipo di crittografia dei dati.
    </simpara>
    <simpara> <!--XXX pacchetto?? classe libreria   -->
     Il modo più semplice per aggirare questo problema è innanzitutto creare il proprio pacchetto di crittografia,
     e quindi utilizzarlo nei tuoi script <acronym>PHP</acronym>. <acronym>PHP</acronym>
     può aiutarti con diverse estensioni, come <link
     linkend="book.openssl">OpenSSL</link> e <link
     linkend="book.sodium">Sodium</link>, che copre un'ampia varietà di algoritmi di crittografia. 
     Lo script cripta i dati prima di inserirli nel database e li decripta
     durante il recupero. Vedere i riferimenti per ulteriori esempi 
     su come funziona la crittografia.<!-- XXX 1 controllo -->
    </simpara>

    <sect2 xml:id="security.database.storage.hashing">
    <title>Hashing</title>
     <simpara>
      Nel caso di dati veramente nascosti(estremamente /privati- segreti- ), se non è necessaria la loro rappresentazione grezza(originale - in chiaro )
      (p.es. non dev'essere visualizzato), è necessario prendere in considerazione l'hashing.
      L'esempio ben noto di hashing è la memorizzazione della password criptata tramite hashing 
      (è il salvataggio dell'hash della password) nel database, 
      invece della password stessa.
     </simpara>
     <simpara>
      Le funzioni per le <link linkend="ref.password">password</link>
      possono fornire un modo semplice per eseguire l'hashing dei dati sensibili e lavorare con questi hash.
     </simpara>
     <simpara>
      <function>password_hash</function> viene utilizzato per eseguire l'hashing di una determinata stringa utilizzando
      l'algoritmo più potente attualmente disponibile e <function>password_verify</function>
      controlla se la password fornita corrisponde all'hash memorizzato nel database.
     </simpara>
     <example> 
      <title>Campo per l'Hash della password</title>
      <programlisting role="php">
<![CDATA[
<?php

// storing password hash
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            pg_escape_string($username),
            password_hash($password, PASSWORD_DEFAULT));
$result = pg_query($connection, $query);

// querying if user submitted the right password
$query = sprintf("SELECT pwd FROM users WHERE name='%s';",
            pg_escape_string($username));
$row = pg_fetch_assoc(pg_query($connection, $query));

if ($row && password_verify($password, $row['pwd'])) {
    echo 'Welcome, ' . htmlspecialchars($username) . '!';
} else {
    echo 'Authentication failed for ' . htmlspecialchars($username) . '.';
}

?>
]]>
      </programlisting>
     </example>
    </sect2>
   </sect1>
   <sect1 xml:id="security.database.sql-injection">
    <title>SQL Injection</title>
    <simpara>
     L'SQL injection è una tecnica dove un utente malintenzionato sfrutta i difetti del
     codice responsabile della creazione di query SQL dinamiche.
     L'aggressore può accedere a sezioni privilegiate dell'applicazione,
     recuperare tutte le informazioni dal database, manomettere i dati esistenti,
     o addirittura eseguire comandi pericolosi a livello di sistema sul database <!-- sarebbe macchina host-->
     ospite(host). La vulnerabilità si verifica quando gli sviluppatori concatenano o
     interpolano dati arbitrari nelle loro istruzioni SQL.
    </simpara>
    <para>
     <example>
      <title> <!-- XXX 1 controllo -->
       Dividere il set di risultati in pagine ... e creare superutenti <!-- amministratori -->
       (PostgreSQL)
      </title>
      <simpara>
       Nell'esempio seguente, l'input dell'utente viene interpolato <!--binding--> direttamente nella
       Query SQL che consente all'aggressore di ottenere un account superuser <!--amministratore--> nel database.
      </simpara>
      <programlisting role="php">
<![CDATA[
<?php

$offset = $_GET['offset']; // beware, no input validation!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
$result = pg_query($conn, $query);

?>
]]>
      </programlisting>
     </example>
      Di solito gli utenti usano i collegamenti "next", "previous" dove l'<varname>$offset</varname>
      viene passato nell'<acronym>URL</acronym>. Lo script si aspetta che l'<varname>$offset</varname> 
      sia un numero. Tuttavia, cosa succede se qualcuno prova a craccarlo
      aggiungendo quanto segue all'<acronym>URL</acronym>?
      <informalexample>
       <programlisting role="sql">
<![CDATA[
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--
]]>
       </programlisting>
      </informalexample>
      Se ciò dovesse accadere, lo script fornirebbe un accesso d'amministratore all'aggressore.
      Tieni presente che <literal>0;</literal> fornisce un offset valido alla query originale 
      e la terminerebbe.
    </para>
    <note>
     <para>
      È una tecnica comune per forzare il parser SQL a ignorare il resto del file <!--della richiesta-->
      con una query scritta dal programmatore con <literal>--</literal> che introduce <!-- con \-\- inserisce i commenti in sql -->
      i commenti in SQL.
     </para>
    </note>
    <para>
     Un modo possibile per ottenere le password è analizzare le pagine dei risultati di ricerca.
     L'unica cosa che l'attaccante deve fare è vedere se sono presenti variabili inviate
     utilizzate nelle istruzioni SQL che non vengono gestite correttamente. Questi filtri possono essere impostati
     comunemente in una forma personalizzata di <literal>WHERE, ORDER BY,
     Clausole LIMIT</literal> e <literal>OFFSET</literal> in <literal>SELECT</literal>
     dichiarazioni. Se il tuo database supporta il costrutto <literal>UNION</literal>,
     l'aggressore potrebbe tentare di aggiungere un'intera query a quella originale da elencare <!-- in modo da -->
     password da una tabella arbitraria. <!-- è fortemente consigliato salvare/inserire solola chiave hash -->Si consiglia vivamente di salvare sole le secure hash delle password 
     anziché le password stesse.


     A feasible way to gain passwords is to circumvent your search result pages.
     The only thing the attacker needs to do is to see if there are any submitted variables
     used in SQL statements which are not handled properly. These filters can be set
     commonly in a preceding form to customize <literal>WHERE, ORDER BY,
     LIMIT</literal> and <literal>OFFSET</literal> clauses in <literal>SELECT</literal>
     statements. If your database supports the <literal>UNION</literal> construct,
     the attacker may try to append an entire query to the original one to list
     passwords from an arbitrary table. It is strongly recommended to store only
     secure hashes of passwords instead of the passwords themselves.
     <example>
      <title>Elencare gli articoli... e alcune password (può essere usato su qualunque database server).</title>
      <programlisting role="php">
<![CDATA[
<?php

$query  = "SELECT id, name, inserted, size FROM products
           WHERE size = '$size'";
$result = odbc_exec($conn, $query);

?>
]]>
      </programlisting>
     </example>
     La parte statica della query può essere combinata con un'altra <!-- The static part of the query can be combined with another-->
     <literal>SELECT</literal>dichiarazione che rivela tutte le password: <!-- statement which reveals all passwords:-->
     <informalexample>
      <programlisting role="sql">
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Anche le istruzioni <literal>UPDATE</literal> e <literal>INSERT</literal> sono
     suscettibili a tali attacchi.

     <!--<literal>UPDATE</literal> and <literal>INSERT</literal> statements are also
     susceptible to such attacks.-->
     <example>
     <title>Dalla reimpostazione di una password... all'acquisizione di più privilegi (qualsiasi database server)</title>
      <!--From resetting a password ... to gaining more privileges (any database server)-->
      <programlisting role="php">
<![CDATA[
<?php
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
?>
]]>
      </programlisting>
     </example>
     Se un utente malintenzionato invia la stringa <!-- XXX da rivedere -->
     <literal>' or uid like '%admin%</literal> in <varname>$uid</varname> per
     cambiare la password dell'amministratore oppure impostare la variabile <varname>$pwd</varname> semplicemente con
     <literal>hehehe', trusted=100, admin='yes</literal> per ottenere  
     privilegi più elevati, la query verrà corrotta:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php

// $uid: ' or uid like '%admin%
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%';";

// $pwd: hehehe', trusted=100, admin='yes
$query = "UPDATE usertable SET pwd='hehehe', trusted=100, admin='yes' WHERE
...;";

?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara> <!--XXX tradurre-->
     Mentre è scontato che un malintenzionato debba possederne almeno alcune nozioni 
     dell'architettura del database per condurre un'attacco riuscito <!-- a buon fine - riuscire -->, 
     è spesso molto semplice ottenere queste informazioni . Per esempio,
     il codice può far parte di un software open source ed essere disponibile al pubblico.
     Tali informazioni potranno anche essere divulgate
     tramite codice closed-source, anche se è codificato, offuscato o compilato -
     e anche tramite il proprio codice attraverso la visualizzazione di messaggi di errore
     Altri metodi includono l'uso di nomi di tabelle e colonne tipici.  Per
     ad esempio, un modulo d'accesso che utilizza una tabella "utenti" con nomi di colonne
     "id", "username" e "password".
    </simpara>
    <para>
     <example>

      <title>Attaccare il sistema operativo host del database (MSSQL Server)</title>
       <simpara>
        Un preoccupante esempio di come è possibile accedere ai comandi a livello di sistema operativo
        da parte di alcuni database su host.
       </simpara>

      <programlisting role="php">
<![CDATA[
<?php

$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);

?>
]]>
      </programlisting>
     </example>
     Se l'attaccante invia la stringa 
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     a <varname>$prod</varname>, quindi <varname>$query</varname> sarà:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php

$query  = "SELECT * FROM products
           WHERE id LIKE '%a%'
           exec master..xp_cmdshell 'net user test testpass /ADD' --%'";
$result = mssql_query($query);

?>
]]>
      </programlisting>
     </informalexample>
     MSSQL Server esegue le istruzioni SQL nel batch incluso un comando
     per aggiungere un nuovo utente al database degli account locali. Se questa applicazione
     era in esecuzione come <literal>sa</literal> e il servizio MSSQLSERVER era
     in esecuzione con privilegi sufficienti, l'utente malintenzionato ora avrebbe un'account
     con cui accedere a questa macchina.
    </para>
    <note>
     <para>
      Alcuni esempi sopra riportati sono legati ad uno specifico database , ma
      non significa che un attacco simile sia impossibile verso altri prodotti.
      Il tuo database potrebbe essere altrettanto vulnerabile in un altri modi.
     </para>
    </note>
    <para>
     <mediaobject>
      <alt>Un esempio divertente dei problemi riguardanti SQL injection</alt>
      <imageobject>
       <imagedata fileref="it/security/figures/xkcd-bobby-tables.png" format="PNG"/>
      </imageobject>
      <caption>
       <simpara>
        Image courtesy of <link xlink:href="&url.xkcd;327">xkcd</link>
       </simpara>
      </caption>
     </mediaobject>
    </para>

    <sect2 xml:id="security.database.avoiding">
     <title>Tecniche di elusione</title><!-- evasione - elusione  -->
     <para>
      Il modo consigliato per evitare l'SQL injection è associare tutti i dati 
      tramite istruzioni preparate. L'utilizzo di query parametrizzate non è 
      sufficiente per evitare completamente l'iniezione SQL, ma è il modo più 
      semplice e sicuro per fornire input alle istruzioni SQL. Tutti i letterali
      di dati dinamici nelle clausole <literal>WHERE</literal>,
     <literal>SET</literal> e <literal>VALUES</literal> devono essere sostituiti
      con segnaposto. I dati effettivi verranno associati durante l'esecuzione e 
      inviati separatamente dal comando SQL.
     </para>

     <para>
      Il binding dei parametri può essere utilizzato solo per i dati. Altre 
      parti dinamiche della query SQL devono essere filtrate in base a un elenco
      noto di valori consentiti.
     </para><!-- XXX tradotto da rivedere-->
     <para>
      <example>
      <title> Eludere un'SQL injection usando PDO prepared Statement - Avoiding SQL injection by using PDO prepared statements</title>
       <programlisting role="php">
<![CDATA[
<?php

// The dynamic SQL part is validated against expected values
$sortingOrder = $_GET['sortingOrder'] === 'DESC' ? 'DESC' : 'ASC';
$productId = $_GET['productId'];
// The SQL is prepared with a placeholder
$stmt = $pdo->prepare("SELECT * FROM products WHERE id LIKE ? ORDER BY price {$sortingOrder}");
// The value is provided with LIKE wildcards
$stmt->execute(["%{$productId}%"]);

?>
]]>
       </programlisting>
      </example>
     </para>

     <simpara>
      Le Prepared statement Sono fornite.
      <link linkend="pdo.prepared-statements">da PDO</link>,
      <link linkend="mysqli.quickstart.prepared-statements">da MySQLi</link>,
      e da altre librerie per database.
     </simpara>     

     <simpara>
      Gli attacchi SQL injection sfruttano principalmente il codice scritto
      senza fare attanzione alla sicurezza. Non fidarti mai di nessun input, specialmente
      dal lato client, anche se proviene da una casella di selezione,
      un campo di input nascosto o un cookie. Il primo esempio mostra che una query così
      semplice può causare disastri.
    </simpara>

     <para>
      Una strategia di difesa in profondità comporta diverse buone pratiche di codifica:

      A defense-in-depth strategy involves several good coding practices:
      <itemizedlist>
       <listitem>
        <simpara>
         Non connettersi mai al database come superutente o come proprietario del database. Utilizzare sempre utenti personalizzati con privilegi minimi.

         Never connect to the database as a superuser or as the database owner.
         Use always customized users with minimal privileges.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Controlla se l'input fornito ha il tipo di dati previsto. <acronym>PHP</acronym> ha
         una vasta gamma di funzioni di convalida dell'input, da quelle più semplici
         che si trovano in <link linkend="ref.var">Funzioni variabili</link> e
         in <link linkend="ref.ctype">Funzioni tipo carattere</link>
         (ad esempio <function>is_numeric</function>, <function>ctype_digit</function>
         rispettivamente) e oltre al
         supporto per <link linkend="ref.pcre">Espressioni regolari compatibili con Perl</link>.


         Check if the given input has the expected data type. <acronym>PHP</acronym> has
         a wide range of input validating functions, from the simplest ones
         found in <link linkend="ref.var">Variable Functions</link> and
         in <link linkend="ref.ctype">Character Type Functions</link>
         (e.g. <function>is_numeric</function>, <function>ctype_digit</function>
         respectively) and onwards to the
         <link linkend="ref.pcre">Perl Compatible Regular Expressions</link>
         support.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Se l'applicazione prevede un input numerico, prendi in considerazione la verifica dei dati
         con <function>ctype_digit</function>, modifica silenziosamente il suo tipo
         usando <function>settype</function> o usa la sua rappresentazione numerica
         con <function>sprintf</function>.

         If the application expects numerical input, consider verifying data
         with <function>ctype_digit</function>, silently change its type
         using <function>settype</function>, or use its numeric representation
         by <function>sprintf</function>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Se il livello del database non supporta variabili di binding, allora
         cita ogni valore non numerico fornito dall'utente che viene passato al
         database con la funzione di escape della stringa specifica del database (ad esempio
         <function>mysql_real_escape_string</function>,
         <function>sqlite_escape_string</function>, ecc.).
         Le funzioni generiche come <function>addslashes</function> sono utili solo
         in un ambiente molto specifico (ad esempio MySQL in un set di caratteri a singolo byte
         con <varname>NO_BACKSLASH_ESCAPES</varname> disabilitato), quindi è
         meglio evitarle.

         If the database layer doesn't support binding variables then
         quote each non-numeric user-supplied value that is passed to the
         database with the database-specific string escape function (e.g.
         <function>mysql_real_escape_string</function>,
         <function>sqlite_escape_string</function>, etc.).
         Generic functions like <function>addslashes</function> are useful only
         in a very specific environment (e.g. MySQL in a single-byte character
         set with disabled <varname>NO_BACKSLASH_ESCAPES</varname>), so it is
         better to avoid them.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Non stampare informazioni specifiche del database, in particolare
         sullo schema, con mezzi leciti o illeciti. Vedere anche <link
         linkend="security.errors">Segnalazione degli errori</link> e <link
         linkend="ref.errorfunc">Funzioni di gestione e registrazione degli errori</link>.

         Do not print out any database-specific information, especially
         about the schema, by fair means or foul. See also <link
         linkend="security.errors">Error Reporting</link> and <link
         linkend="ref.errorfunc">Error Handling and Logging Functions</link>.
        </simpara>
       </listitem>
      </itemizedlist>
     </para>

     <simpara>
      Oltre a ciò, puoi trarre vantaggio dalla registrazione delle query all'interno del tuo script
      o dal database stesso, se supporta la registrazione. Ovviamente, la registrazione non è in grado
      di prevenire alcun tentativo dannoso, ma può essere utile risalire a quale
      applicazione è stata aggirata. Il registro non è utile di per sé, ma
      attraverso le informazioni che contiene. Più dettagli sono generalmente meglio di meno.

      Besides these, you benefit from logging queries either within your script
      or by the database itself, if it supports logging. Obviously, the logging is unable
      to prevent any harmful attempt, but it can be helpful to trace back which
      application has been circumvented. The log is not useful by itself but
      through the information it contains. More detail is generally better than less.
     </simpara><!--XXX traduzione da sistemare -->
    </sect2>
   </sect1>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
