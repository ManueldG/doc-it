<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 87d3bf2e9ea7da5abbeca3e60ea7cf7abfa6f7f3 Maintainer: Manuel dG Status: ready -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <chapter xml:id="security.cgi-bin" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <title>PHP installato come binario CGI</title>

   <sect1 xml:id="security.cgi-bin.attacks">
    <title>Possibili attacchi</title>
    <simpara>
      L'utilizzo di PHP come binario <acronym>CGI</acronym> è un'opzione che per qualche
      motivo non si volglia integrare PHP come modulo del server (come Apache)
       o utilizzeranno PHP con diversi tipi di wrapper <acronym>CGI</acronym> per creare
      con <command>chroot</command> e <command>setuid</command> ambienti
      sicuri per gli script. Questa configurazione di solito prevede l'installazione
      del'eseguibile <command>php</command> nella directory del server web <filename class="directory">cgi-bin</filename>.
      L'avviso CERT <link xlink:href="&url.cert;">CA-96.11</link> sconsiglia
      di posizionare interpreti in <filename class="directory">cgi-bin</filename>. 
      Anche se il binario <command>php</command> può essere utilizzato in modo autonomo,
      PHP è progettato per prevenire gli attacchi possibili di questa configurazione:
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Accesso al file system: <filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
        Le informazioni in una query ovvero la parte dell'URL dopo il punto interrogativo (<literal>?</literal>) vengono
        passate come argomenti dalla riga di comando all'interprete dall'interfaccia CGI. 
        Di solito gli interpreti aprono ed eseguono il file
        specificato specificato nel primo argomento sulla riga di comando.
      </simpara>
      <simpara>
       Quando PHP viene invocato come binario CGI, <command>php</command> non interpreta
       gli argomenti della riga di comando.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Accesso a qualsiasi documento web sul server:<filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
       Le informazioni sul percorso dell'URL dopo il nome del binario PHP,
       <filename role="uri">/secret/doc.html</filename> sono
       convenzionalmente usate per specificare il nome del file da
       aprire e interpretare dal programma <acronym>CGI</acronym>.
       Solitamente alcune direttive di configurazione del server web (Apache:
       <literal>Action</literal>) sono usate per reindirizzare le richieste a documenti come
       <filename
       role="url">http://my.host/secret/script.php</filename> all'interprete PHP. Con questa configurazione, 
       il server web prima controlla i permessi di accesso alla directory <filename
       role="uri">/secret</filename>, e poi crea la richiesta reindirizzata <filename
       role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
       Purtroppo, se la richiesta è data originariamente in questo formato, 
       il server web non esegue alcun controllo di accesso per il file <filename
       role="uri">/secret/script.php</filename>, ma solo per il file
       <filename role="uri">/cgi-bin/php</filename>. In questo modo
       qualsiasi utente in grado di accedere a <filename
       role="uri">/cgi-bin/php</filename> è in grado di accedere a qualsiasi
       documento protetto sul server web. <!--XXX suona male-->
       
      </simpara>
      <simpara>
       In PHP, le direttive di configurazione runtime <link
       linkend="ini.cgi.force-redirect">cgi.force_redirect</link>, <link
       linkend="ini.doc-root">doc_root</link> e <link
       linkend="ini.user-dir">user_dir</link> possono essere utilizzate per prevenire
       questo attacco, se l'albero dei documenti del server ha directory
       con restrizioni di accesso. Vedere di seguito per una spiegazione completa
       delle diverse combinazioni. <!--XXX controllo-->

       In PHP, runtime configuration directives <link
       linkend="ini.cgi.force-redirect">cgi.force_redirect</link>, <link
       linkend="ini.doc-root">doc_root</link> and <link
       linkend="ini.user-dir">user_dir</link> can be used to prevent
       this attack, if the server document tree has any directories
       with access restrictions.  See below for full the explanation
       of the different combinations.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect1>

   <sect1 xml:id="security.cgi-bin.default">
    <title>1° Caso :solo files publici serviti - only public files served</title>

    <simpara>
     Se il tuo server non ha alcun contenuto che non sia limitato
     da password o controllo di accesso basato su IP, non c'è bisogno di
     queste opzioni di configurazione. Se il tuo server web non ti consente
     di effettuare reindirizzamenti, o il server non ha un modo per
     comunicare al binario PHP che la richiesta è una richiesta reindirizzata in modo sicuro, puoi abilitare la
     direttiva <link linkend="ini.cgi.force-redirect">cgi.force_redirect</link>
     ini. Devi comunque assicurarti che i tuoi script PHP
     non si basino su un modo o sull'altro di chiamare lo script,
     né direttamente <filename
     role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
     né tramite reindirizzamento <filename
     role="php">http://my.host/dir/script.php</filename>.


     If your server does not have any content that is not restricted
     by password or IP based access control, there is no need for
     these configuration options.  If your web server does not allow
     you to do redirects, or the server does not have a way to
     communicate to the PHP binary that the request is a safely
     redirected request, you can enable the
     <link linkend="ini.cgi.force-redirect">cgi.force_redirect</link>
     ini directive.  You still have to make sure your PHP
     scripts do not rely on one or another way of calling the script,
     neither by directly <filename
     role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
     nor by redirection <filename
     role="php">http://my.host/dir/script.php</filename>.
    </simpara>
    <simpara>
     Redirection can be configured in Apache by using <literal>AddHandler</literal> and
     <literal>Action</literal> directives (see below).
    </simpara>
   </sect1>

   <sect1 xml:id="security.cgi-bin.force-redirect">
    <title>Case 2: using <literal>cgi.force_redirect</literal></title>
    <simpara>
     The configuration directive <link
     linkend="ini.cgi.force-redirect">cgi.force_redirect</link>
     prevents anyone from calling <command>php</command>
     directly with a URL like <filename
     role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>.
     Instead, PHP will only parse in this mode if it has gone through
     a web server redirect rule.
    </simpara>
    <simpara>
     Usually the redirection in the Apache configuration is done with
     the following directives:
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
     This option has only been tested with the Apache web server, and
     relies on Apache to set the non-standard CGI environment variable
     <envar>REDIRECT_STATUS</envar> on redirected requests.  If your
     web server does not support any way of telling if the request is
     direct or redirected, you cannot use this option and you must use
     one of the other ways of running the CGI version documented
     here.
    </simpara>
   </sect1>

   <sect1 xml:id="security.cgi-bin.doc-root">
    <title>Case 3: setting doc_root or user_dir</title>
    <simpara>
     To include active content, like scripts and executables, in the
     web server document directories is sometimes considered an insecure
     practice.  If, because of some configuration mistake, the scripts
     are not executed but displayed as regular HTML documents, this
     may result in leakage of intellectual property or security
     information like passwords.  Therefore many sysadmins will prefer
     setting up another directory structure for scripts that are
     accessible only through the PHP CGI, and therefore always
     interpreted and not displayed as such.
    </simpara>
    <simpara>
     Also if the method for making sure the requests are not
     redirected, as described in the previous section, is not
     available, it is necessary to set up a
     script <link linkend="ini.doc-root">doc_root</link> that is
     different from web document root.
    </simpara>
    <simpara>
     You can set the PHP script document root by the configuration
     directive <link linkend="ini.doc-root">doc_root</link> in the
     <link linkend="configuration.file">configuration file</link>, or
     you can set the environment variable
     <envar>PHP_DOCUMENT_ROOT</envar>.  If it is set, the <acronym>CGI</acronym>
     version of PHP will always construct the file name to open with this
     <parameter>doc_root</parameter> and the path information in the
     request, so you can be sure no script is executed outside this
     directory (except for <parameter>user_dir</parameter>
     below).
    </simpara>
    <simpara>
     Another option usable here is <link
     linkend="ini.user-dir">user_dir</link>.  When <parameter>user_dir</parameter> is
     unset, only thing controlling the opened file name is
     <parameter>doc_root</parameter>.  Opening a URL like <filename
     role="url">http://my.host/~user/doc.php</filename> does not
     result in opening a file under users home directory, but a file
     called <filename role="uri">~user/doc.php</filename> under
     <parameter>doc_root</parameter> (yes, a directory name starting with a tilde
     [<literal>~</literal>]).
    </simpara>
    <simpara>
     If <parameter>user_dir</parameter> is set to for example <filename
     role="dir">public_php</filename>, a request like <filename
     role="url">http://my.host/~user/doc.php</filename> will open a
     file called <filename>doc.php</filename> under the directory
     named <filename role="dir">public_php</filename> under the home
     directory of the user.  If the home of the user is <filename
     role="dir">/home/user</filename>, the file executed is
     <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
     <parameter>user_dir</parameter> expansion happens regardless of
     the <parameter>doc_root</parameter> setting, so you can control
     the document root and user directory access
     separately.
    </simpara>
   </sect1>

   <sect1 xml:id="security.cgi-bin.shell">
    <title>Case 4: PHP parser outside of web tree</title>
    <para>
     A very secure option is to put the PHP parser binary somewhere
     outside of the web tree of files.  In <filename
     role="dir">/usr/local/bin</filename>, for example.  The only real
     downside to this option is that you will now have to put a line
     similar to:
     <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     as the first line of any file containing PHP tags.  You will also
     need to make the file executable.  That is, treat it exactly as
     you would treat any other CGI script written in Perl or sh or any
     other common scripting language which uses the
     <literal>#!</literal> shell-escape mechanism for launching
     itself.
    </para>
    <para>
     To get PHP to handle <envar>PATH_INFO</envar> and
     <envar>PATH_TRANSLATED</envar> information correctly with this
     setup, the <link linkend="ini.cgi.discard-path">cgi.discard_path</link>
     ini directive has to be enabled.
    </para>
   </sect1>

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
